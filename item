class Item:
    def __init__(self, name, description):
        self.name = name
        self.description = description

    def __str__(self):
        return f"{self.name}: {self.description}"

class Weapon(Item):
    def __init__(self, name, damage):
        if damage < 0:
            raise ValueError("Damage value must be non-negative.")
        super().__init__(name, f"A {name} dealing {damage} damage")
        self.damage = damage

class Potion(Item):
    def __init__(self, name, heal_amount):
        if heal_amount < 0:
            raise ValueError("Heal amount must be non-negative.")
        super().__init__(name, f"A {name} that heals {heal_amount} HP")
        self.heal_amount = heal_amount

    def use(self, character):
        current_health = character.stats.get("health", 0)
        max_health = character.stats.get("max_health", 0)

        if current_health < max_health:
            healed = min(self.heal_amount, max_health - current_health)
            character.stats["health"] += healed
            print(f"{character.name} used {self.name}, healing {healed} HP!")
            return True
        print(f"{character.name} is already at full health!")
        return False
class BlazeArrow:
    def __init__(self, name, length, damage):
        self.name = name
        self.length = length
        self.damage = damage

    def do_damage(self, target):
        target.health = max(target.health - self.damage, 0)  # Prevents negative health
        print(f"{target.name} took {self.damage} damage. Remaining health: {target.health}")

# Example of a target class
class Target:
    def __init__(self, name, health):
        self.name = name
        self.health = health

# Example usage
enemy = Target("Goblin", 50)
arrow = BlazeArrow("Flaming Arrow", 1.5, 20)

arrow.do_damage(enemy)  # Goblin took 20 damage. Remaining health: 30
arrow.do_damage(enemy)  # Goblin took 20 damage. Remaining health: 10
